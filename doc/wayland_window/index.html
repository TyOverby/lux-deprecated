<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `wayland_window` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, wayland_window">

    <title>wayland_window - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'wayland_window', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>wayland_window</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/wayland_window/lib.rs.html#1-97' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Wayland Window, a minimalistic decoration-drawing library for
wayland applications.</p>

<p>This crate is only usable in conjuction of the
<a href="https://crates.io/crates/wayland-client"><code>wayland-client</code></a> crate.</p>

<h2 id="creating-a-decorated-shell-surface" class='section-header'><a
                           href="#creating-a-decorated-shell-surface">Creating a decorated shell surface</a></h2>
<p>Creating a decorated window is as simple as wrapping it in a
<code>DecoratedSurface</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>wayland_window</span>::<span class='ident'>DecoratedSurface</span>;
<span class='kw'>let</span> <span class='ident'>decorated</span> <span class='op'>=</span> <span class='ident'>DecoratedSurface</span>::<span class='ident'>new</span>(<span class='ident'>my_surface</span>, <span class='ident'>width</span>, <span class='ident'>height</span>, <span class='kw-2'>&amp;</span><span class='ident'>registry</span>, <span class='kw-2'>&amp;</span><span class='ident'>seat</span>);
</pre>

<p>As you can see, you need to pass the <code>Registry</code> and a <code>Seat</code> as well. It is required
for the library to be able to create the surfaces to draw the borders, and register
the callback to detect user input in the borders, for resizeing and move. These callback
will be registered on the seat you passed as argument. (So if you are on a setup with more
than one pointer, only one of them will be able to resize the window).</p>

<h2 id="processing-the-events" class='section-header'><a
                           href="#processing-the-events">Processing the events</a></h2>
<p>The <code>DecoratedSurface</code> object will not resize your window itself, as it cannot do it.</p>

<p>When the user clicks on a border and starts a resize, the server will start to generate a
number of <code>configure</code> events on the shell surface. You&#39;ll need to register a callback on
it to handle them:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>decorated</span>.<span class='ident'>get_shell</span>().<span class='ident'>set_configure_callback</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>edge</span>, <span class='ident'>width</span>, <span class='ident'>height</span><span class='op'>|</span> {
    <span class='comment'>/* ... */</span>
});
</pre>

<p>The wayland server can (and will) generate a ton of <code>configure</code> events during a single
<code>Display::dispatch()</code> if the user is currently resizing the window. You are only required to
process the last one, and if you try to handle them all your aplication will be very
laggy.</p>

<p>The proper way is to use the callback to only store them in a container, overwriting the
the previous one each time, and manually checking if one has been received in the main loop
of your program, like this:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// create a shared storage: (width, heigh, need_resize ?)</span>
<span class='kw'>let</span> <span class='ident'>need_resize</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>((<span class='number'>0</span>, <span class='number'>0</span>, <span class='boolval'>false</span>)));
<span class='comment'>// clone it and put it in the callback</span>
<span class='kw'>let</span> <span class='ident'>my_need_resize</span> <span class='op'>=</span> <span class='ident'>need_resize</span>.<span class='ident'>clone</span>();
<span class='ident'>decorated</span>.<span class='ident'>w</span>.<span class='ident'>get_shell</span>().<span class='ident'>set_configure_callback</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>_edge</span>, <span class='ident'>width</span>, <span class='ident'>height</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>guard</span> <span class='op'>=</span> <span class='ident'>my_newsize</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='comment'>// we overwrite it each time, to only keep the last one</span>
    <span class='op'>*</span><span class='ident'>guard</span> <span class='op'>=</span> (<span class='ident'>width</span>, <span class='ident'>height</span>, <span class='boolval'>true</span>);
});
<span class='comment'>// then handle all this in the main loop:</span>
<span class='kw'>loop</span> {
    <span class='ident'>display</span>.<span class='ident'>dispatch</span>();
    <span class='kw'>let</span> <span class='ident'>guard</span> <span class='op'>=</span> <span class='ident'>need_resize</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> (<span class='ident'>width</span>, <span class='ident'>height</span>, <span class='ident'>resize</span>) <span class='op'>=</span> <span class='op'>*</span><span class='ident'>guard</span>;
    <span class='kw'>if</span> <span class='ident'>resize</span> {
        <span class='comment'>/* handle the resizing here */</span>
    }
    <span class='comment'>// reset the storage</span>
    <span class='op'>*</span><span class='ident'>guard</span> <span class='op'>=</span> (<span class='number'>0</span>, <span class='number'>0</span>, <span class='boolval'>false</span>);
}
</pre>

<h2 id="resizing-the-surface" class='section-header'><a
                           href="#resizing-the-surface">Resizing the surface</a></h2>
<p>When resizing your main surface, you need to tell the <code>DecoratedSurface</code> that it
must update its dimensions. This is very simple:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>/* update the buffer of decorated */</span>
<span class='ident'>decorated</span>.<span class='ident'>resize</span>(<span class='ident'>width</span>, <span class='ident'>height</span>);
<span class='ident'>decorated</span>.<span class='ident'>get_shell</span>().<span class='ident'>commit</span>();
</pre>

<p>If you do this as a response of a <code>configure</code> event, note the following points:</p>

<ul>
<li>You do not have to respect the exact sizes provided by the compositor, it is
just a hint. You can even ignore it if you don&#39;t want the window to be resized.</li>
<li>In case you chose to ignore the resize, it can be appropiate to still resize your
window to its current size (update the buffer to the compositor), as the compositer
might have resized your window without telling you.</li>
<li>The size hint provided by the compositor counts the borders size, to get the real
size hint for your interior surface, use the function <code>substract_borders(..)</code> provided
by this library.</li>
</ul>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.DecoratedSurface.html'
                               title='wayland_window::DecoratedSurface'>DecoratedSurface</a></td>
                        <td class='docblock short'>
                             <p>A wrapper for a decorated surface.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.SurfaceGuard.html'
                               title='wayland_window::SurfaceGuard'>SurfaceGuard</a></td>
                        <td class='docblock short'>
                             <p>A wrapper around a reference to the surface you
stored in a <code>DecoratedSurface</code>.</p>

                        </td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.substract_borders.html'
                               title='wayland_window::substract_borders'>substract_borders</a></td>
                        <td class='docblock short'>
                             <p>Substracts the border dimensions from the given dimensions.</p>

                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
            <p>
                Search functions by type signature (e.g.
                <code>vec -> usize</code>)
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "wayland_window";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>