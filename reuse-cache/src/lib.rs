use std::rc::Rc;
use std::cell::RefCell;
use std::ops::{Deref, DerefMut};

/// A pool that contains elements that can be recycled when they are finished being used.
#[derive(Clone)]
pub struct ReusePool<T> {
    all: Rc<Vec<RefCell<(bool, Option<T>)>>>
}

/// An element that logically came from a ReusePool.
///
/// If this item came from `ReusePool::get*()`, then when this Item is
/// Dropped, it will be recycled into the pool.
///
/// If this item came from the `from_value` constructor, then when this Item is
/// Dropped, the contained value will be dropped as well.
pub struct Item<T> {
    /// Maybe have this be a weak reference instead?
    parent_pool: Option<ReusePool<T>>,
    idx: usize,
    item: Option<T>,
    poisoned: bool
}

impl <T> ReusePool<T> {
    /// Creates a new ReusePool with a given size and where each element is
    /// initialized by the init function.
    pub fn new<F: FnMut() -> T>(count: usize, mut init: F) -> ReusePool<T> {
        let mut v = Vec::new();
        v.extend((0 .. count).map(|_| RefCell::new((false, Some(init())))));
        ReusePool { all: Rc::new(v) }
    }

    /// Returns an unpoisoned item from the pool if possible.
    pub fn get(&self) -> Option<Item<T>> {
        for (i, slot) in self.all.iter().enumerate() {
            if !slot.borrow().0 && slot.borrow().1.is_some() {
                return Some(Item {
                    parent_pool: Some(ReusePool{all: self.all.clone()}),
                    idx: i,
                    item: slot.borrow_mut().1.take(),
                    poisoned: false
                })
            }
        }

        None
    }

    /// Returns an unpoisoned item from the pool, or a given value, if one
    /// is not available.
    pub fn get_or(&self, v: T) -> Item<T> {
        self.get().unwrap_or(Item::from_value(v))
    }

    /// Returns an unpoisoned item from the pool, or value generated by the function
    /// `f` if one is not available
    pub fn get_or_else<F: FnOnce() -> T>(&self, f: F) -> Item<T> {
        self.get().unwrap_or_else(|| {
            Item::from_value(f())
        })
    }

    /// Removes poison from all the internal items
    pub fn unpoison_all(&self) {
        for slot in self.all.iter() {
            *(&mut slot.borrow_mut().0) = false;
        }
    }
}

impl <T> Item<T> {
    /// Directly construct an Item.  When this Item is dropped, it will
    /// not be returned to any Pool.
    pub fn from_value(value: T) -> Item<T> {
        Item {
            parent_pool: None,
            idx: 0,
            item: Some(value),
            poisoned: false
        }
    }

    /// Replaces the value of the item with another one.
    pub fn replace(&mut self, new: T) -> T {
        let old = self.item.take().unwrap();
        self.item = Some(new);
        old
    }

    /// Poisons this value.
    ///
    /// Even when this item is returned to the pool, this item will not be
    /// used until `unpoison_all` is called on the owning pool.
    pub fn poison(mut self) {
        self.poisoned = true;
    }
}

impl <T> Deref for Item<T> {
    type Target = T;

    fn deref(&self) -> &T {
        self.item.as_ref().unwrap()
    }
}

impl <T> DerefMut for Item<T> {
    fn deref_mut(&mut self) -> &mut T {
        self.item.as_mut().unwrap()
    }
}

impl <T> Drop for Item<T> {
    fn drop(&mut self) {
        let it = self.item.take();
        if let Some(pc) = self.parent_pool.take() {
            *(pc.all.get(self.idx).unwrap().borrow_mut()) = (self.poisoned, it);
        }
    }
}

#[test]
fn test_empty() {
    let rc = ReusePool::new(0, || 0u32);
    assert!(rc.get().is_none())
}

#[test]
fn test_single() {
    let rc = ReusePool::new(1, || 5u32);
    assert!(&*rc.get().unwrap() == &5u32)
}

#[test]
fn test_reuse() {
    let rc = ReusePool::new(1, || 5u32);

    {
        let mut it = rc.get().unwrap();
        *it = 10u32;
    }

    {
        let it = rc.get().unwrap();
        assert!(&*it == &10u32)
    }
}

#[test]
fn test_taken() {
    let rc = ReusePool::new(1, || 5u32);
    let it1 = rc.get();
    assert!(it1.is_some());
    let it2 = rc.get();
    assert!(it2.is_none());
}

#[test]
fn test_replace() {
    let rc = ReusePool::new(1, || 5u32);
    {
        let mut it = rc.get().unwrap();
        assert!(it.replace(4) == 5);
    }

    {
        let it = rc.get().unwrap();
        assert!(*it == 4)
    }
}

#[test]
fn test_poison() {
    let rc = ReusePool::new(1, || 5u32);

    {
        let mut it = rc.get().unwrap();
        *it = 10u32;
        it.poison()
    }

    {
        assert!(rc.get().is_none());
    }
}

#[test]
fn test_unpoison() {
    let rc = ReusePool::new(1, || 5u32);

    {
        let mut it = rc.get().unwrap();
        *it = 10u32;
        it.poison()
    }

    rc.unpoison_all();

    {
        assert!(rc.get().is_some());
    }
}
